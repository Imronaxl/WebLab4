import { Component, OnInit, OnDestroy, ViewChild, ElementRef, AfterViewInit, HostListener } from '@angular/core';
import { Router } from '@angular/router';
import { MessageService } from 'primeng/api';
import { AuthService } from '../../services/auth.service';
import { PointService } from '../../services/point.service';
import { PointResult } from '../../models/point.model';

@Component({
  selector: 'app-main',
  template: `
    <div class="responsive-container">
      <div class="header surface-card p-3 shadow-2 flex justify-content-between align-items-center mb-3 rounded">
        <div class="text-lg font-bold">Лаб. №4 | Гулахмадзода Имрон | Группа: P3232 | Вариант: 32434212</div>
        <p-button label="Выйти" icon="pi pi-sign-out" severity="danger" (click)="logout()"></p-button>
      </div>
      
      <div class="grid-container">
        <div class="form-container">
          <p-card header="Параметры точки" class="h-full">
            <div class="flex flex-column gap-4">
              <div class="field">
                <label class="block mb-2 font-medium">Координата X:</label>
                <p-dropdown [options]="xOptions" [(ngModel)]="selectedX" placeholder="Выберите X" [style]="{'width': '100%'}"></p-dropdown>
              </div>
              
              <div class="field">
                <label class="block mb-2 font-medium">Координата Y (-5 ... 3):</label>
                <input pInputText type="number" [(ngModel)]="yValue" (input)="validateY()" [style]="{'width': '100%'}" placeholder="Введите Y" step="0.1" min="-5" max="3" />
                <small *ngIf="yError" class="p-error block mt-1">Y должен быть числом от -5 до 3</small>
              </div>
              
              <div class="field">
                <label class="block mb-2 font-medium">Радиус R:</label>
                <p-dropdown [options]="rOptions" [(ngModel)]="selectedR" (onChange)="onRadiusChange()" placeholder="Выберите R" [style]="{'width': '100%'}"></p-dropdown>
              </div>
              
              <div class="flex flex-column gap-2">
                <p-button label="Проверить точку" icon="pi pi-check" (click)="checkPoint()" [disabled]="yError || !selectedR || selectedX === null" class="w-full"></p-button>
                <p-button label="Очистить таблицу" icon="pi pi-trash" severity="secondary" (click)="clearPoints()" class="w-full"></p-button>
              </div>
              
              <div class="mt-4 p-3 border-round surface-section">
                <h4 class="mt-0 mb-2">Информация:</h4>
                <p class="text-sm mb-1">X: {{selectedX || 'не выбрано'}}</p>
                <p class="text-sm mb-1">Y: {{yValue || 'не введено'}}</p>
                <p class="text-sm mb-0">R: {{selectedR || 'не выбран'}}</p>
              </div>
            </div>
          </p-card>
        </div>
        
        <div class="canvas-container">
          <p-card header="Область на координатной плоскости" class="h-full">
            <div class="flex flex-column align-items-center justify-content-center">
              <div class="canvas-wrapper" #canvasContainer>
                <canvas
                  #canvas
                  (click)="onCanvasClick($event)"
                  class="border-1 border-300 rounded pointer"
                ></canvas>
              </div>
            </div>
            <div class="mt-3 text-center text-sm text-color-secondary">Кликните на графике для добавления точки</div>
          </p-card>
        </div>
      </div>
      
      <div class="mt-4 table-container" #tableContainer>
        <p-card header="Результаты проверок">
          <p-table [value]="points" [paginator]="true" [rows]="10" [rowsPerPageOptions]="[5, 10, 20]" styleClass="p-datatable-sm" [tableStyle]="{'min-width': '50rem'}">
            <ng-template pTemplate="header">
              <tr>
                <th>X</th>
                <th>Y</th>
                <th>R</th>
                <th>Результат</th>
                <th>Время проверки</th>
              </tr>
            </ng-template>
            <ng-template pTemplate="body" let-point>
              <tr>
                <td>{{point.x}}</td>
                <td>{{point.y}}</td>
                <td>{{point.r}}</td>
                <td><span [class]="point.hit ? 'hit' : 'miss'">{{point.hit ? 'Попал' : 'Мимо'}}</span></td>
                <td>{{point.checkDate}}</td>
              </tr>
            </ng-template>
            <ng-template pTemplate="emptymessage">
              <tr>
                <td colspan="5" class="text-center p-4">Нет данных</td>
              </tr>
            </ng-template>
          </p-table>
        </p-card>
      </div>
    </div>
  `,
  styles: [`.h-full { height: 100%; }`]
})
export class MainComponent implements OnInit, AfterViewInit, OnDestroy {
  @ViewChild('canvas') canvasRef!: ElementRef<HTMLCanvasElement>;
  @ViewChild('canvasContainer') canvasContainerRef!: ElementRef<HTMLDivElement>;
  
  xOptions = [
    { label: '-2', value: -2 }, { label: '-1.5', value: -1.5 }, { label: '-1', value: -1 },
    { label: '-0.5', value: -0.5 }, { label: '0', value: 0 }, { label: '0.5', value: 0.5 },
    { label: '1', value: 1 }, { label: '1.5', value: 1.5 }, { label: '2', value: 2 }
  ];
  
  rOptions = [
    { label: '0.5', value: 0.5 }, { label: '1', value: 1 },
    { label: '1.5', value: 1.5 }, { label: '2', value: 2 }
  ];
  
  selectedX: number | null = null;
  yValue = '';
  selectedR: number | null = 1;
  yError = false;
  points: PointResult[] = [];
  
  private ctx!: CanvasRenderingContext2D;
  // Параметры виртуального графика, пересчитываются при каждом ресайзе
  private canvasWidth = 500;
  private canvasHeight = 500;
  private centerX = 250;
  private centerY = 250;
  private scale = 40;
  private readonly dataSpace = { minX: -5, maxX: 5, minY: -6, maxY: 4 };
  
  constructor(
    private authService: AuthService,
    private pointService: PointService,
    private router: Router,
    private messageService: MessageService
  ) {}
  
  ngOnInit(): void { this.loadPoints(); }
  ngAfterViewInit(): void { 
    // даём layoutу отрендериться, затем настраиваем холст и рисуем
    setTimeout(() => {
      this.initCanvas(); 
      this.resizeCanvas();
      this.drawGraph(); 
    }, 0);
  }
  ngOnDestroy(): void {}
  
  @HostListener('window:resize')
  onResize(): void { 
    this.resizeCanvas();
    this.drawGraph(); 
  }
  
  private initCanvas(): void {
    const canvas = this.canvasRef.nativeElement;
    const ctx = canvas.getContext('2d');
    if (ctx) this.ctx = ctx;
  }

  /**
   * Подгоняет реальный размер canvas под ширину контейнера
   * и пересчитывает виртуальную систему координат графика.
   */
  private resizeCanvas(): void {
    if (!this.canvasRef || !this.canvasContainerRef) return;
    const canvas = this.canvasRef.nativeElement;
    const container = this.canvasContainerRef.nativeElement;
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    const cssSize = rect.width || 500; // квадрат, ширина = высоте

    // Внутреннее разрешение (для чёткости) – умножаем на dpr
    canvas.width = cssSize * dpr;
    canvas.height = cssSize * dpr;

    // Логические размеры для математики кликов и рисования – используем CSS‑пиксели
    this.canvasWidth = cssSize;
    this.canvasHeight = cssSize;

    // Настраиваем трансформацию контекста так, чтобы мы рисовали в CSS‑координатах
    const ctx = canvas.getContext('2d');
    if (ctx) {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      this.ctx = ctx;
    }

    // Пересчитываем систему координат данных -> пиксели
    this.recalculateTransform();
  }

  private recalculateTransform(): void {
    const padding = 40; // отступы от краёв в пикселях
    const spanX = this.dataSpace.maxX - this.dataSpace.minX; // 10
    const spanY = this.dataSpace.maxY - this.dataSpace.minY; // 10

    const usableWidth = this.canvasWidth - 2 * padding;
    const usableHeight = this.canvasHeight - 2 * padding;

    // одинаковый масштаб по X и Y, чтобы фигуры не искажались
    this.scale = Math.min(usableWidth / spanX, usableHeight / spanY);

    // центр координат (0,0) посередине по X и Y
    this.centerX = this.canvasWidth / 2;
    this.centerY = this.canvasHeight / 2;
  }
  
  validateY(): void {
    const value = parseFloat(this.yValue);
    this.yError = isNaN(value) || value < -5 || value > 3;
    if (!this.yError) {
      // нормализуем до шага 0.1, чтобы форма и клик всегда совпадали
      this.yValue = (Math.round(value * 10) / 10).toFixed(1);
    }
  }
  
  onRadiusChange(): void {
    this.drawGraph();
    this.loadPoints();
  }
  
  checkPoint(): void {
    if (this.yError || this.selectedX === null || this.selectedR === null) {
      this.messageService.add({ severity: 'warn', summary: 'Предупреждение', detail: 'Заполните все поля корректно' });
      return;
    }
    
    const y = parseFloat(this.yValue);
    this.pointService.addPoint({ x: this.selectedX, y: y, r: this.selectedR }).subscribe({
      next: (result) => {
        this.points.unshift(result);
        this.drawGraph();
        this.messageService.add({ severity: 'success', summary: 'Успех', detail: `Точка (${this.selectedX}, ${y.toFixed(2)}) проверена` });
      },
      error: () => {
        this.messageService.add({ severity: 'error', summary: 'Ошибка', detail: 'Ошибка при проверке точки' });
      }
    });
  }
  
  onCanvasClick(event: MouseEvent): void {
    if (!this.selectedR) {
      this.messageService.add({ severity: 'warn', summary: 'Предупреждение', detail: 'Сначала выберите радиус R' });
      return;
    }
    
    const canvas = this.canvasRef.nativeElement;
    const rect = canvas.getBoundingClientRect();
    
    // Координаты клика в CSS‑пикселях внутри холста
    const clickX = event.clientX - rect.left;
    const clickY = event.clientY - rect.top;
    
    // Подбираем ближайшую допустимую дискретную точку в пикселях (манхэттеново расстояние)
    const valuesX = this.xOptions.map(o => o.value as number);
    let bestX = valuesX[0];
    let bestY = -5;
    let bestDist = Number.POSITIVE_INFINITY;
    
    for (const vx of valuesX) {
      for (let vy = -5; vy <= 3.0001; vy += 0.1) {
        const px = this.centerX + vx * this.scale;
        const py = this.centerY - vy * this.scale;
        const dx = Math.abs(clickX - px);
        const dy = Math.abs(clickY - py);
        const dist = dx + dy; // манхэттеново расстояние
        if (dist < bestDist) {
          bestDist = dist;
          bestX = vx;
          bestY = Math.round(vy * 10) / 10;
        }
      }
    }
    
    this.selectedX = bestX;
    this.yValue = bestY.toFixed(1);
    this.validateY();
    
    if (!this.yError) {
      this.checkPoint();
    }
  }

  loadPoints(): void {
    this.pointService.getPoints().subscribe({
      next: (points) => {
        this.points = Array.isArray(points) ? points : [];
        this.drawGraph();
      },
      error: () => {
        this.messageService.add({ severity: 'error', summary: 'Ошибка', detail: 'Ошибка при загрузке точек' });
      }
    });
  }
  
  clearPoints(): void {
    this.pointService.clearPoints().subscribe({
      next: () => {
        // Гарантированно подтягиваем актуальное состояние с сервера
        this.loadPoints();
        this.messageService.add({ severity: 'success', summary: 'Успех', detail: 'Таблица очищена' });
      },
      error: (err) => {
        this.messageService.add({ severity: 'error', summary: 'Ошибка', detail: 'Ошибка при очистке таблицы' });
      }
    });
  }
  
  logout(): void {
    this.authService.logout();
    this.router.navigate(['/login']);
  }
  
  private drawGraph(): void {
    if (!this.ctx) return;
    this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);
    this.drawGrid();
    this.drawAxes();
    if (this.selectedR) this.drawArea(this.selectedR);
    this.drawPoints();
  }
  
  private drawGrid(): void {
    this.ctx.strokeStyle = '#e5e7eb';
    this.ctx.lineWidth = 1;
    
    for (let i = -5; i <= 5; i++) {
      const x = this.centerX + i * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(x, 0);
      this.ctx.lineTo(x, this.canvasHeight);
      this.ctx.stroke();
    }
    
    for (let i = -6; i <= 4; i++) {
      const y = this.centerY - i * this.scale;
      this.ctx.beginPath();
      this.ctx.moveTo(0, y);
      this.ctx.lineTo(this.canvasWidth, y);
      this.ctx.stroke();
    }
  }
  
  private drawAxes(): void {
    this.ctx.strokeStyle = '#374151';
    this.ctx.lineWidth = 2;
    
    this.ctx.beginPath();
    this.ctx.moveTo(0, this.centerY);
    this.ctx.lineTo(this.canvasWidth, this.centerY);
    this.ctx.stroke();
    
    this.ctx.beginPath();
    this.ctx.moveTo(this.centerX, 0);
    this.ctx.lineTo(this.centerX, this.canvasHeight);
    this.ctx.stroke();
    
    this.ctx.fillStyle = '#374151';
    this.ctx.beginPath();
    this.ctx.moveTo(this.canvasWidth - 10, this.centerY);
    this.ctx.lineTo(this.canvasWidth - 20, this.centerY - 5);
    this.ctx.lineTo(this.canvasWidth - 20, this.centerY + 5);
    this.ctx.fill();
    
    this.ctx.beginPath();
    this.ctx.moveTo(this.centerX, 10);
    this.ctx.lineTo(this.centerX - 5, 20);
    this.ctx.lineTo(this.centerX + 5, 20);
    this.ctx.fill();
    
    this.ctx.fillStyle = '#374151';
    this.ctx.font = '14px Arial';
    this.ctx.textAlign = 'center';
    this.ctx.fillText('X', this.canvasWidth - 20, this.centerY + 25);
    this.ctx.fillText('Y', this.centerX + 20, 15);
    
    for (let i = -5; i <= 5; i++) {
      if (i === 0) continue;
      const x = this.centerX + i * this.scale;
      this.ctx.fillText(i.toString(), x, this.centerY + 20);
    }
    
    for (let i = -6; i <= 4; i++) {
      if (i === 0) continue;
      const y = this.centerY - i * this.scale;
      this.ctx.fillText(i.toString(), this.centerX - 20, y);
    }
    
    this.ctx.fillText('0', this.centerX - 20, this.centerY + 20);
  }
  
  private drawArea(r: number): void {
    const scaledR = r * this.scale;
    this.ctx.fillStyle = 'rgba(59, 130, 246, 0.3)';
    this.ctx.strokeStyle = '#3b82f6';
    this.ctx.lineWidth = 2;
    
    this.ctx.beginPath();
    this.ctx.moveTo(this.centerX, this.centerY);
    this.ctx.arc(this.centerX, this.centerY, scaledR / 2, -Math.PI / 2, 0);
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
    
    this.ctx.beginPath();
    this.ctx.moveTo(this.centerX, this.centerY);
    this.ctx.lineTo(this.centerX - scaledR, this.centerY);
    this.ctx.lineTo(this.centerX, this.centerY - scaledR / 2);
    this.ctx.closePath();
    this.ctx.fill();
    this.ctx.stroke();
    
    this.ctx.beginPath();
    this.ctx.rect(this.centerX - scaledR / 2, this.centerY, scaledR / 2, scaledR);
    this.ctx.fill();
    this.ctx.stroke();
  }
  
  private drawPoints(): void {
    this.points.forEach(point => {
      if (point.r !== this.selectedR) return;
      const x = this.centerX + point.x * this.scale;
      const y = this.centerY - point.y * this.scale;
      this.ctx.beginPath();
      this.ctx.arc(x, y, 6, 0, Math.PI * 2);
      this.ctx.fillStyle = point.hit ? '#22c55e' : '#ef4444';
      this.ctx.strokeStyle = point.hit ? '#16a34a' : '#dc2626';
      this.ctx.lineWidth = 2;
      this.ctx.fill();
      this.ctx.stroke();
    });
  }
  
  private findNearestX(value: number): number {
    const values = this.xOptions.map(o => o.value);
    let closest = values[0];
    let minDiff = Math.abs(value - closest);
    for (const v of values) {
      const diff = Math.abs(value - v);
      if (diff < minDiff) {
        minDiff = diff;
        closest = v;
      }
    }
    return closest;
  }
}
